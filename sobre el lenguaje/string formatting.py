# book of python tricks, capítulo de las strings...
# Hay 4 métodos, de más antiguo a más moderno son ...

#1 – “Old Style” String Formatting: con el operador %
# https://docs.python.org/3/library/stdtypes.html#old-string-formatting
# es similar al C con printf
name = 'Mike'
print('Hola, %s' % name)
# Resultado: Hola, Mike
# Lo que hace el operador es reemplazar lo que va después en la cadena en el lugar apropiado
# Realmente lo que ve la función print es la cadena 'Hola, Mike'...
# previamente el operador % a reemplazado %s con el valor almacenado en name...
# La s le indica que pase el valor a string con la función str()

value = 123000
print('El código es: %s' % value)
print('El código es: %x' % value)  # x hace que convierte a string con lowercase hexadecimal
print('El código es: %X' % value)  # x hace que convierte a string con uppercase hexadecimal

# Podemos aplicar el operador % a un sólo valor.. si fueran a varios hay que ponerlos en una tupla...
print('Hola %s... El código es: 0X%X' % (name, value))

# Muchísimas opciones, aunque ya obsoleto... preferible métodos más modernos...
# De todas formas, consultar docs...

# Método 2: “New Style” String Formatting
# https://docs.python.org/3/library/stdtypes.html#str.format    Aquí está la función str.format() que hace todo
# https://docs.python.org/3/library/string.html#string-formatting   Format String Syntax !!!
# Esta sintaxis además es compartida tb por el método 4!!!
# Ahora ya pasamos totalmente de los %
# Lo que se ha hecho es crear un método, que se aplica a las strings...
# El método es str.format() y es similar a los % pero mucho más elegante...
# En la cadena original, lo que vayamos a sustituir está en {}.
# Dentro de los paréntesis indicaremos el orden (si pasamos a format parámetros posicioneles)
# o la 'key', si pasamos a format parámetros keyword....
cadena_base = 'Hola {0}, cómo estás esta {1}. Mañana me voy a {2}'
cadena_1 = cadena_base.format('Juan', 'tarde', 'Luxemburgo')
cadena_2 = cadena_base.format('Luisa', 'noche', 'Cantabria')
print(cadena_1)
print(cadena_2)
# Muy potente la opción con keyword params...
name = 'Miguel'
error = 5876342
print('Hola {name}, hay un error tipo 0x{error:x}!'.format(name=name, error=error))

# Método 3 – Literal String Interpolation (Python 3.6+)
# Una nueva forma de formatear strings... se llama Formatted String Literals... (f-Strings)
# es muy potente... nos deja meter directamente ya las expresiones dentro de los literales
a = 5
b = 10
print(f'Hola {name}... Five plus ten is {a + b} and not {2 * (a + b)}.')
# Realmente esto lo transforma el parser al recorrer el programa... cambia lo que está en {} al valor apropiado...
# Lo que es genial es que estas f-strings soportan la sintaxis anterior del método 2...
# https://docs.python.org/3/library/string.html#string-formatting   Format String Syntax !!!
print(f"Hey {name}, there's a {error:#x} error!")

# 4 – Template Strings
# Es más simple realmente, y menos potente, pero para muchos casos es lo indicado...
# Funciona con template strings...... por lo que habrá que importar la clase Template!!!
from string import Template
# Simplemente definimos un template string: una cadena que incluye campos especiales...
# y luego llamamos al método substitute para que sustituya esos campos por lo que le digamos...
t = Template('Hello, cómo estás $name? Ayer vi a $name2, te manda recuerdos...')
name2 = 'Juana'
resultado = t.substitute(name='Miguel', name2=name2)
# Obs. el primer name2 es el nombre del keyword arg, el segundo el del objeto... obviamente no tienen pq ser igual
print(resultado)
# observar que estos templates no permiten nada como convertir a hexadecimal, etc...
# si lo necesitamos tenemos que hacerlo nosotros!!!
t = Template('Hello, cómo estás $name? Oye, el programa dio el error $error!!')
resultado = t.substitute(name=name, error=hex(error))
print(resultado)

# ¿Para qué utilizar template strings si el método de las f-strings es más potente?
# In my opinion, the best use case for template strings is when you’re handling format strings
# generated by users of your program. Due to their reduced complexity, template strings are a safer choice.

# O sea, son más seguras... por ejemplo, con f-strings se pueden introducir vulnerabilidades
# que permiten acceder a datos arbitrarios dentro de un programa....
# Un usuario malicioso podría aprovecharlo!!!!

# Ejemplo de vulnerabilidad.... NO LO ENTIENDO BIEN, ADEMÄS NO ME SALE!!!
# Let us assume this CONFIG holds some sensitive information
CONFIG = {"KEY": "ASXFYFGK78989"}


class PeopleInfo:
    def __init__(self, fname, lname):
        self.fname = fname
        self.lname = lname


def get_name_for_avatar(avatar_str, people_obj):
    return avatar_str.format(people_obj=people_obj)


# Driver Code
people = PeopleInfo('GEEKS', 'FORGEEKS')

# case 1: st obtained from user
st = input('Prueba de vulnerabilidad... Escribe el formato para el nombre del avatar ----> ')
resultado = get_name_for_avatar(st, people_obj=people)
print(resultado)

# Si entramos Avatar_{people_obj.fname}_{people_obj.lname}
# Sale Avatar_GEEKS_FORGEEKS .....
# Pero, y si es un usuario malicioso???
# Si entramos para el formato del nombre de avatar...
# El usuario entra: {people_obj.__init__.__globals__[CONFIG][KEY]}
# La salida es.....
# ASXFYFGK78989    # QUé desastre!!!
# Hagamos la prueba... en vez de que lo escriba lo vamos a asignar ya!!
st = '{people_obj.__init__.__globals__[CONFIG][KEY]}'
resultado = get_name_for_avatar(st, people_obj=people)
print(resultado)

# ¿Que método usar?
# Si las cadenas las proporciona el usuario mejor usar Template Strings (méotod 4) pq tienen mecanismos de seguridad
# que dificultan el ataque...
# En otro caso, lo más cómodo es el méotodo 3 de las string interpolation (f-strings) o, si no podemos por < py 3.6,
# pues usar el método 2, claro, con str.format().






