# Lambdas son pequeñas funciones anónimas...
# Se comportan como las funciones normales definidas con def

# vamos a definir la función add de dos formas...
# son totalmente equivalente...

def add_1(x, y):
    return x + y

add_2 = lambda x, y: x + y

print(add_1(4, 6))
print(add_2(6, 7))

# el uso del lambda para definir add_2 no tiene mucho sentido, queda más claro definiendo add_2 con def..
# el lambda se usa normalmente como una expresión funcional, inline, e inmediatamente aplicable...
# son minifunciones de una orden y automáticamente retornan el valor, llevan un return implícito
print((lambda x, y: x*y)(7, 9))

# casos prácticos para los que vale la pena utilizar un lambda...
# podemos utilizar lambdas, por ejemplo, para funciones de ordenar...
# ahorramos mucho tiempo evitando definir aparte las funciones de ordenamiento...
tuples = [(1, 'd'), (2, 'b'), (4, 'a'), (3, 'c')]
# definimos inline una función que ordena basándose en la segunda componente....
print(sorted(tuples, key=lambda x: x[1]))

# aquí ordenamos basándonos en el cuadrado...
print(sorted(range(-6, 5), key=lambda x: x**2))

# también es más cómodo utilizar los ejemplos de antes (en funciones.py) retornando funciones lambda...
# versión de antes...
def make_adder(n):
    def add(x):
        return x + n  # recuerda el parámetro pasado a la función padre!! es una clousure!!!
    return add

# versión nueva, el código es mucho más corto e incluso más claro...
def make_adder_con_lambdas(n):
    return lambda x: x + n


# cuidado con el uso de Lambdas, no es aconsejable en muchas ocasiones pq oscurece el significado del código...
